// Code generated by protoc-gen-go. DO NOT EDIT.
// source: starcoder.proto

/*
Package protobuf is a generated protocol buffer package.

It is generated from these files:
	starcoder.proto

It has these top-level messages:
	StartProcessRequest
	StartProcessReply
	EndProcessRequest
	EndProcessReply
*/
package protobuf

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Response status
type StartProcessReply_Status int32

const (
	// Successfully started process.
	StartProcessReply_SUCCESS StartProcessReply_Status = 0
	// Unknown error starting process.
	StartProcessReply_UNKNOWN_ERROR StartProcessReply_Status = 255
)

var StartProcessReply_Status_name = map[int32]string{
	0:   "SUCCESS",
	255: "UNKNOWN_ERROR",
}
var StartProcessReply_Status_value = map[string]int32{
	"SUCCESS":       0,
	"UNKNOWN_ERROR": 255,
}

func (x StartProcessReply_Status) String() string {
	return proto.EnumName(StartProcessReply_Status_name, int32(x))
}
func (StartProcessReply_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

// Response status
type EndProcessReply_Status int32

const (
	// Successfully started process.
	EndProcessReply_SUCCESS EndProcessReply_Status = 0
	// Unknown error starting process.
	EndProcessReply_UNKNOWN_ERROR EndProcessReply_Status = 255
)

var EndProcessReply_Status_name = map[int32]string{
	0:   "SUCCESS",
	255: "UNKNOWN_ERROR",
}
var EndProcessReply_Status_value = map[string]int32{
	"SUCCESS":       0,
	"UNKNOWN_ERROR": 255,
}

func (x EndProcessReply_Status) String() string {
	return proto.EnumName(EndProcessReply_Status_name, int32(x))
}
func (EndProcessReply_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

// The request message containing parameters for starting a process
type StartProcessRequest struct {
	// Filename of GNURadio script to run
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	// Arbitrary command line parameters to be passed to the GNURadio script
	Parameters []*StartProcessRequest_Parameter `protobuf:"bytes,2,rep,name=parameters" json:"parameters,omitempty"`
}

func (m *StartProcessRequest) Reset()                    { *m = StartProcessRequest{} }
func (m *StartProcessRequest) String() string            { return proto.CompactTextString(m) }
func (*StartProcessRequest) ProtoMessage()               {}
func (*StartProcessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *StartProcessRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *StartProcessRequest) GetParameters() []*StartProcessRequest_Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// Key value pair representing a parameter to be passed to the script
type StartProcessRequest_Parameter struct {
	// Name of parameter
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Value to assign the parameter
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *StartProcessRequest_Parameter) Reset()         { *m = StartProcessRequest_Parameter{} }
func (m *StartProcessRequest_Parameter) String() string { return proto.CompactTextString(m) }
func (*StartProcessRequest_Parameter) ProtoMessage()    {}
func (*StartProcessRequest_Parameter) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0}
}

func (m *StartProcessRequest_Parameter) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StartProcessRequest_Parameter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// The message response to a StartProcessRequest
type StartProcessReply struct {
	// Unique Process ID of the process that was started
	ProcessId string `protobuf:"bytes,1,opt,name=processId" json:"processId,omitempty"`
	// Response status
	Status StartProcessReply_Status `protobuf:"varint,2,opt,name=status,enum=starcoder.StartProcessReply_Status" json:"status,omitempty"`
	// Error message
	Error string `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *StartProcessReply) Reset()                    { *m = StartProcessReply{} }
func (m *StartProcessReply) String() string            { return proto.CompactTextString(m) }
func (*StartProcessReply) ProtoMessage()               {}
func (*StartProcessReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StartProcessReply) GetProcessId() string {
	if m != nil {
		return m.ProcessId
	}
	return ""
}

func (m *StartProcessReply) GetStatus() StartProcessReply_Status {
	if m != nil {
		return m.Status
	}
	return StartProcessReply_SUCCESS
}

func (m *StartProcessReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// The request message containing parameters for enidng a process
type EndProcessRequest struct {
	// Process ID of process to end
	ProcessId string `protobuf:"bytes,1,opt,name=processId" json:"processId,omitempty"`
}

func (m *EndProcessRequest) Reset()                    { *m = EndProcessRequest{} }
func (m *EndProcessRequest) String() string            { return proto.CompactTextString(m) }
func (*EndProcessRequest) ProtoMessage()               {}
func (*EndProcessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *EndProcessRequest) GetProcessId() string {
	if m != nil {
		return m.ProcessId
	}
	return ""
}

// The message response to an EndProcessRequest
type EndProcessReply struct {
	// Response status
	Status EndProcessReply_Status `protobuf:"varint,2,opt,name=status,enum=starcoder.EndProcessReply_Status" json:"status,omitempty"`
	// Error message
	Error string `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *EndProcessReply) Reset()                    { *m = EndProcessReply{} }
func (m *EndProcessReply) String() string            { return proto.CompactTextString(m) }
func (*EndProcessReply) ProtoMessage()               {}
func (*EndProcessReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EndProcessReply) GetStatus() EndProcessReply_Status {
	if m != nil {
		return m.Status
	}
	return EndProcessReply_SUCCESS
}

func (m *EndProcessReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*StartProcessRequest)(nil), "starcoder.StartProcessRequest")
	proto.RegisterType((*StartProcessRequest_Parameter)(nil), "starcoder.StartProcessRequest.Parameter")
	proto.RegisterType((*StartProcessReply)(nil), "starcoder.StartProcessReply")
	proto.RegisterType((*EndProcessRequest)(nil), "starcoder.EndProcessRequest")
	proto.RegisterType((*EndProcessReply)(nil), "starcoder.EndProcessReply")
	proto.RegisterEnum("starcoder.StartProcessReply_Status", StartProcessReply_Status_name, StartProcessReply_Status_value)
	proto.RegisterEnum("starcoder.EndProcessReply_Status", EndProcessReply_Status_name, EndProcessReply_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ProcessManager service

type ProcessManagerClient interface {
	// Create a process
	StartProcess(ctx context.Context, in *StartProcessRequest, opts ...grpc.CallOption) (*StartProcessReply, error)
	// End a process
	EndProcess(ctx context.Context, in *EndProcessRequest, opts ...grpc.CallOption) (*EndProcessReply, error)
}

type processManagerClient struct {
	cc *grpc.ClientConn
}

func NewProcessManagerClient(cc *grpc.ClientConn) ProcessManagerClient {
	return &processManagerClient{cc}
}

func (c *processManagerClient) StartProcess(ctx context.Context, in *StartProcessRequest, opts ...grpc.CallOption) (*StartProcessReply, error) {
	out := new(StartProcessReply)
	err := grpc.Invoke(ctx, "/starcoder.ProcessManager/StartProcess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processManagerClient) EndProcess(ctx context.Context, in *EndProcessRequest, opts ...grpc.CallOption) (*EndProcessReply, error) {
	out := new(EndProcessReply)
	err := grpc.Invoke(ctx, "/starcoder.ProcessManager/EndProcess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ProcessManager service

type ProcessManagerServer interface {
	// Create a process
	StartProcess(context.Context, *StartProcessRequest) (*StartProcessReply, error)
	// End a process
	EndProcess(context.Context, *EndProcessRequest) (*EndProcessReply, error)
}

func RegisterProcessManagerServer(s *grpc.Server, srv ProcessManagerServer) {
	s.RegisterService(&_ProcessManager_serviceDesc, srv)
}

func _ProcessManager_StartProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessManagerServer).StartProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/starcoder.ProcessManager/StartProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessManagerServer).StartProcess(ctx, req.(*StartProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessManager_EndProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessManagerServer).EndProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/starcoder.ProcessManager/EndProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessManagerServer).EndProcess(ctx, req.(*EndProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProcessManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "starcoder.ProcessManager",
	HandlerType: (*ProcessManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartProcess",
			Handler:    _ProcessManager_StartProcess_Handler,
		},
		{
			MethodName: "EndProcess",
			Handler:    _ProcessManager_EndProcess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "starcoder.proto",
}

func init() { proto.RegisterFile("starcoder.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 347 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x52, 0x4f, 0x4b, 0x02, 0x41,
	0x14, 0x77, 0x94, 0xcc, 0x7d, 0x96, 0x7f, 0x5e, 0x1d, 0x96, 0x45, 0xc2, 0xa6, 0x8b, 0x5d, 0x84,
	0xf4, 0x14, 0xdd, 0x12, 0xa1, 0x88, 0x56, 0x99, 0x45, 0x82, 0x2e, 0x31, 0xea, 0x18, 0xd1, 0xea,
	0x6e, 0x33, 0xb3, 0x81, 0x1f, 0xa2, 0x2f, 0xd2, 0xa5, 0xbe, 0x61, 0xb1, 0x7f, 0xd2, 0x4d, 0x72,
	0x4f, 0xdd, 0xe6, 0xbd, 0x79, 0xbf, 0x7f, 0x8f, 0x07, 0x55, 0xa5, 0xb9, 0x9c, 0x78, 0x53, 0x21,
	0xdb, 0xbe, 0xf4, 0xb4, 0x87, 0xc6, 0xaa, 0x41, 0x3f, 0x09, 0x1c, 0x38, 0x9a, 0x4b, 0x3d, 0x94,
	0xde, 0x44, 0x28, 0xc5, 0xc4, 0x4b, 0x20, 0x94, 0x46, 0x0b, 0x4a, 0xb3, 0x27, 0x57, 0x2c, 0xf8,
	0x5c, 0x98, 0xa4, 0x49, 0x5a, 0x06, 0x5b, 0xd5, 0x78, 0x05, 0xe0, 0x73, 0xc9, 0xe7, 0x42, 0x0b,
	0xa9, 0xcc, 0x7c, 0xb3, 0xd0, 0x2a, 0x77, 0x5a, 0xed, 0xb5, 0xc8, 0x1f, 0x7c, 0xed, 0xe1, 0x0f,
	0x80, 0xa5, 0xb0, 0x56, 0x17, 0x8c, 0xd5, 0x07, 0xd6, 0xa0, 0xf0, 0x2c, 0x96, 0x89, 0x5a, 0xf8,
	0xc4, 0x43, 0xd8, 0x79, 0xe5, 0x6e, 0x20, 0xcc, 0x7c, 0xd4, 0x8b, 0x0b, 0xfa, 0x41, 0xa0, 0xfe,
	0x5b, 0xc2, 0x77, 0x97, 0xd8, 0x00, 0xc3, 0x8f, 0xeb, 0xeb, 0x69, 0xc2, 0xb1, 0x6e, 0xe0, 0x05,
	0x14, 0x95, 0xe6, 0x3a, 0x50, 0x11, 0x55, 0xa5, 0x73, 0xb2, 0xd5, 0xae, 0xef, 0x2e, 0xc3, 0x8e,
	0x0e, 0x14, 0x4b, 0x20, 0xa1, 0x0d, 0x21, 0xa5, 0x27, 0xcd, 0x42, 0x6c, 0x23, 0x2a, 0xe8, 0x29,
	0x14, 0xe3, 0x39, 0x2c, 0xc3, 0xae, 0x33, 0xea, 0xf5, 0xfa, 0x8e, 0x53, 0xcb, 0x21, 0xc2, 0xfe,
	0xc8, 0xbe, 0xb1, 0x07, 0x77, 0xf6, 0x43, 0x9f, 0xb1, 0x01, 0xab, 0x7d, 0x11, 0x7a, 0x06, 0xf5,
	0xfe, 0x62, 0xba, 0xb1, 0xe1, 0x4c, 0xc3, 0xf4, 0x8d, 0x40, 0x35, 0x8d, 0x09, 0x23, 0x9e, 0x6f,
	0x84, 0x38, 0x4e, 0x85, 0xd8, 0x98, 0xfd, 0xef, 0x08, 0x9d, 0x77, 0x02, 0x95, 0x44, 0xe0, 0x96,
	0x2f, 0xf8, 0xa3, 0x90, 0x68, 0xc3, 0x5e, 0x7a, 0x75, 0x78, 0x94, 0x7d, 0x02, 0x56, 0x23, 0x6b,
	0xe7, 0x34, 0x17, 0x9e, 0xd5, 0x3a, 0x05, 0x36, 0xb6, 0x84, 0x8b, 0xb9, 0xac, 0xed, 0xd1, 0x69,
	0xee, 0x12, 0xee, 0x4b, 0xd1, 0xa1, 0x8f, 0x83, 0xd9, 0xb8, 0x18, 0xbd, 0xba, 0xdf, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x79, 0x7e, 0x81, 0x0f, 0x05, 0x03, 0x00, 0x00,
}
